/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index-play-on-scroll.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/player.js/dist/player-0.1.0.js":
/*!******************************************************!*\
  !*** ../node_modules/player.js/dist/player-0.1.0.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*! Player.js - v0.1.0 - 2017-10-24\n* http://github.com/embedly/player.js\n* Copyright (c) 2017 Embedly; Licensed BSD */\n(function(window, document){\nvar playerjs = {};\n\nplayerjs.DEBUG = false;\nplayerjs.VERSION = '0.0.11';\nplayerjs.CONTEXT = 'player.js';\nplayerjs.POST_MESSAGE = !!window.postMessage;\n\n/*\n* Utils.\n*/\nplayerjs.origin = function(url){\n  // Grab the origin of a URL\n  if (url.substr(0, 2) === '//'){\n    url = window.location.protocol + url;\n  }\n\n  return url.split('/').slice(0,3).join('/');\n};\n\nplayerjs.addEvent = function(elem, type, eventHandle) {\n  if (!elem) { return; }\n  if ( elem.addEventListener ) {\n    elem.addEventListener( type, eventHandle, false );\n  } else if ( elem.attachEvent ) {\n    elem.attachEvent( \"on\" + type, eventHandle );\n  } else {\n    elem[\"on\"+type]=eventHandle;\n  }\n};\n\n// usage: log('inside coolFunc',this,arguments);\n// http://paulirish.com/2009/log-a-lightweight-wrapper-for-consolelog/\nplayerjs.log = function(){\n  playerjs.log.history = playerjs.log.history || [];   // store logs to an array for reference\n  playerjs.log.history.push(arguments);\n  if(window.console && playerjs.DEBUG){\n    window.console.log( Array.prototype.slice.call(arguments) );\n  }\n};\n\n// isFunctions\nplayerjs.isString = function (obj) {\n  return Object.prototype.toString.call(obj) === '[object String]';\n};\n\nplayerjs.isObject = function(obj){\n  return Object.prototype.toString.call(obj) === \"[object Object]\";\n};\n\nplayerjs.isArray = function(obj){\n  return Object.prototype.toString.call(obj) === \"[object Array]\";\n};\n\nplayerjs.isNone = function(obj){\n  return (obj === null || obj === undefined);\n};\n\nplayerjs.has = function(obj, key){\n  return Object.prototype.hasOwnProperty.call(obj, key);\n};\n\n// ie8 doesn't support indexOf in arrays, based on underscore.\nplayerjs.indexOf = function(array, item) {\n  if (array == null){ return -1; }\n  var i = 0, length = array.length;\n  if (Array.prototype.IndexOf && array.indexOf === Array.prototype.IndexOf) {\n    return array.indexOf(item);\n  }\n  for (; i < length; i++) {\n    if (array[i] === item) { return i; }\n  }\n  return -1;\n};\n\n// Assert\nplayerjs.assert = function(test, msg) {\n  if (!test) {\n    throw msg || \"Player.js Assert Failed\";\n  }\n};\n/*\n* Keeper is just a method for keeping track of all the callbacks.\n*/\n\nplayerjs.Keeper = function(){\n  this.init();\n};\n\nplayerjs.Keeper.prototype.init = function(){\n  this.data = {};\n};\n\nplayerjs.Keeper.prototype.getUUID = function(){\n  // Create a random id. #http://stackoverflow.com/a/2117523/564191\n  return 'listener-xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n      var r = Math.random()*16|0, v = c === 'x' ? r : (r&0x3|0x8);\n      return v.toString(16);\n  });\n};\n\nplayerjs.Keeper.prototype.has = function(event, id){\n  if (!this.data.hasOwnProperty(event)){\n    return false;\n  }\n\n  if (playerjs.isNone(id)){\n    return true;\n  }\n\n  // Figure out if we have the event.\n  var events = this.data[event];\n\n  for (var i = 0; i < events.length; i++){\n    if (events[i].id === id){\n      return true;\n    }\n  }\n\n  return false;\n};\n\nplayerjs.Keeper.prototype.add = function(id, event, cb, ctx, one){\n  var d = {\n    id: id,\n    event: event,\n    cb: cb,\n    ctx: ctx,\n    one: one\n  };\n\n  if (this.has(event)){\n    this.data[event].push(d);\n  } else {\n    this.data[event] = [d];\n  }\n};\n\nplayerjs.Keeper.prototype.execute = function(event, id, data, ctx){\n  if (!this.has(event, id)){\n    return false;\n  }\n\n  var keep = [],\n    execute = [];\n\n  for (var i=0; i< this.data[event].length; i++){\n    var d = this.data[event][i];\n\n    // There are omni events, in that they do not have an id. i.e \"ready\".\n    // Or there is an ID and we only want to execute the right id'd method.\n    if (playerjs.isNone(id) || (!playerjs.isNone(id) && d.id === id )){\n\n      execute.push({\n        cb: d.cb,\n        ctx: d.ctx? d.ctx: ctx,\n        data: data\n      });\n\n      // If we only wanted to execute this once.\n      if (d.one === false){\n        keep.push(d);\n      }\n    } else {\n      keep.push(d);\n    }\n  }\n\n  if (keep.length === 0){\n    delete this.data[event];\n  } else {\n    this.data[event] = keep;\n  }\n\n  // We need to execute everything after we deal with the one stuff. otherwise\n  // we have issues to order of operations.\n  for (var n=0; n < execute.length; n++){\n    var e = execute[n];\n    e.cb.call(e.ctx, e.data);\n  }\n};\n\nplayerjs.Keeper.prototype.on = function(id, event, cb, ctx){\n  this.add(id, event, cb, ctx, false);\n};\n\nplayerjs.Keeper.prototype.one = function(id, event, cb, ctx){\n  this.add(id, event, cb, ctx, true);\n};\n\nplayerjs.Keeper.prototype.off = function(event, cb){\n  // We should probably restructure so this is a bit less of a pain.\n  var listeners = [];\n\n  if (!this.data.hasOwnProperty(event)){\n    return listeners;\n  }\n\n  var keep = [];\n\n  // Loop through everything.\n  for (var i=0; i< this.data[event].length; i++){\n    var data = this.data[event][i];\n    // If we only keep if there was a CB and the CB is there.\n    if (!playerjs.isNone(cb) && data.cb !== cb) {\n      keep.push(data);\n    } else if (!playerjs.isNone(data.id)) {\n      listeners.push(data.id);\n    }\n  }\n\n  if (keep.length === 0){\n    delete this.data[event];\n  } else {\n    this.data[event] = keep;\n  }\n\n  return listeners;\n};\n\n/*\n* Player.js is a javascript library for interacting with iframes via\n* postMessage that use an Open Player Spec\n*\n*/\n\nplayerjs.Player = function(elem, options){\n  if (!(this instanceof playerjs.Player)) {\n    return new playerjs.Player(elem, options);\n  }\n  this.init(elem, options);\n};\n\nplayerjs.EVENTS = {\n  READY: 'ready',\n  PLAY: 'play',\n  PAUSE: 'pause',\n  ENDED: 'ended',\n  TIMEUPDATE: 'timeupdate',\n  PROGRESS: 'progress',\n  ERROR: 'error'\n};\n\nplayerjs.EVENTS.all = function(){\n  var all = [];\n  for (var key in playerjs.EVENTS) {\n    if (playerjs.has(playerjs.EVENTS, key) && playerjs.isString(playerjs.EVENTS[key])) {\n      all.push(playerjs.EVENTS[key]);\n    }\n  }\n  return all;\n};\n\nplayerjs.METHODS = {\n  PLAY: 'play',\n  PAUSE: 'pause',\n  GETPAUSED: 'getPaused',\n  MUTE: 'mute',\n  UNMUTE: 'unmute',\n  GETMUTED: 'getMuted',\n  SETVOLUME: 'setVolume',\n  GETVOLUME: 'getVolume',\n  GETDURATION: 'getDuration',\n  SETCURRENTTIME: 'setCurrentTime',\n  GETCURRENTTIME:'getCurrentTime',\n  SETLOOP: 'setLoop',\n  GETLOOP: 'getLoop',\n  REMOVEEVENTLISTENER: 'removeEventListener',\n  ADDEVENTLISTENER: 'addEventListener'\n};\n\nplayerjs.METHODS.all = function(){\n  var all = [];\n  for (var key in playerjs.METHODS) {\n    if (playerjs.has(playerjs.METHODS, key) && playerjs.isString(playerjs.METHODS[key])) {\n      all.push(playerjs.METHODS[key]);\n    }\n  }\n  return all;\n};\n\nplayerjs.READIED = [];\n\nplayerjs.Player.prototype.init = function(elem, options){\n\n  var self = this;\n\n  if (playerjs.isString(elem)){\n    elem = document.getElementById(elem);\n  }\n\n  this.elem = elem;\n\n  // make sure we have an iframe\n  playerjs.assert(elem.nodeName === 'IFRAME',\n    'playerjs.Player constructor requires an Iframe, got \"'+elem.nodeName+'\"');\n  playerjs.assert(elem.src,\n    'playerjs.Player constructor requires a Iframe with a \\'src\\' attribute.');\n\n  // Figure out the origin of where we are sending messages.\n  this.origin = playerjs.origin(elem.src);\n\n  // Event handling.\n  this.keeper = new playerjs.Keeper();\n\n  // Queuing before ready.\n  this.isReady = false;\n  this.queue = [];\n\n  // Assume that everything is supported, unless we know otherwise.\n  this.events = playerjs.EVENTS.all();\n  this.methods = playerjs.METHODS.all();\n\n  if (playerjs.POST_MESSAGE){\n    // Set up the reciever.\n    playerjs.addEvent(window, 'message', function(e){\n      self.receive(e);\n    });\n  } else {\n    playerjs.log('Post Message is not Available.');\n  }\n\n  // See if we caught the src event first, otherwise assume we haven't loaded\n  if (playerjs.indexOf(playerjs.READIED, elem.src) > -1){\n    self.loaded = true;\n  } else {\n    // Try the onload event, just lets us give another test.\n    this.elem.onload = function(){\n      self.loaded = true;\n    };\n  }\n};\n\nplayerjs.Player.prototype.send = function(data, callback, ctx){\n  // Add the context and version to the data.\n  data.context = playerjs.CONTEXT;\n  data.version = playerjs.VERSION;\n\n  // We are expecting a response.\n  if (callback) {\n    // Create a UUID\n    var id = this.keeper.getUUID();\n\n    // Set the listener.\n    data.listener = id;\n\n    // Only hang on to this listener once.\n    this.keeper.one(id, data.method, callback, ctx);\n  }\n\n  if (!this.isReady && data.value !== 'ready'){\n    playerjs.log('Player.queue', data);\n    this.queue.push(data);\n    return false;\n  }\n\n  playerjs.log('Player.send', data, this.origin);\n\n  if (this.loaded === true){\n    this.elem.contentWindow.postMessage(JSON.stringify(data), this.origin);\n  }\n\n  return true;\n};\n\nplayerjs.Player.prototype.receive = function(e){\n  playerjs.log('Player.receive', e);\n\n  if (e.origin !== this.origin){\n    return false;\n  }\n\n  var data;\n  try {\n    data = JSON.parse(e.data);\n  } catch (err){\n    // Not a valid response.\n    return false;\n  }\n\n  // abort if this message wasn't a player.js message\n  if (data.context !== playerjs.CONTEXT) {\n    return false;\n  }\n\n  // We need to determine if we are ready.\n  if (data.event === 'ready' && data.value && data.value.src === this.elem.src){\n    this.ready(data);\n  }\n\n  if (this.keeper.has(data.event, data.listener)){\n    this.keeper.execute(data.event, data.listener, data.value, this);\n  }\n};\n\n\nplayerjs.Player.prototype.ready = function(data){\n\n  if (this.isReady === true){\n    return false;\n  }\n\n  // If we got a list of supported methods, we should set them.\n  if (data.value.events){\n    this.events = data.value.events;\n  }\n  if (data.value.methods){\n    this.methods = data.value.methods;\n  }\n\n  // set ready.\n  this.isReady = true;\n  this.loaded = true;\n\n  // Clear the queue\n  for (var i=0; i<this.queue.length; i++){\n    var obj = this.queue[i];\n\n    playerjs.log('Player.dequeue', obj);\n\n    if (data.event === 'ready'){\n      this.keeper.execute(obj.event, obj.listener, true, this);\n    }\n    this.send(obj);\n  }\n  this.queue = [];\n};\n\nplayerjs.Player.prototype.on = function(event, callback, ctx){\n  var id = this.keeper.getUUID();\n\n  if (event === 'ready'){\n    // We only want to call ready once.\n    this.keeper.one(id, event, callback, ctx);\n  } else {\n    this.keeper.on(id, event, callback, ctx);\n  }\n\n  this.send({\n    method: 'addEventListener',\n    value: event,\n    listener: id\n  });\n\n  return true;\n};\n\nplayerjs.Player.prototype.off = function(event, callback){\n\n  var listeners = this.keeper.off(event, callback);\n  playerjs.log('Player.off', listeners);\n\n  if (listeners.length > 0) {\n    for (var i in listeners){\n      this.send({\n        method: 'removeEventListener',\n        value: event,\n        listener: listeners[i]\n      });\n      return true;\n    }\n  }\n\n  return false;\n};\n\n// Based on what ready passed back, we can determine if the events/method are\n// supported by the player.\nplayerjs.Player.prototype.supports = function(evtOrMethod, names){\n\n  playerjs.assert(playerjs.indexOf(['method', 'event'], evtOrMethod) > -1,\n    'evtOrMethod needs to be either \"event\" or \"method\" got ' + evtOrMethod);\n\n  // Make everything an array.\n  names = playerjs.isArray(names) ? names : [names];\n\n  var all = evtOrMethod === 'event' ? this.events : this.methods;\n\n  for (var i=0; i < names.length; i++){\n    if (playerjs.indexOf(all, names[i]) === -1){\n      return false;\n    }\n  }\n\n  return true;\n};\n\n//create function to add to the Player prototype\nfunction createPrototypeFunction(name) {\n\n  return function() {\n\n    var data = {\n      method: name\n    };\n\n    var args = Array.prototype.slice.call(arguments);\n\n    //for getters add the passed parameters to the arguments for the send call\n    if (/^get/.test(name)) {\n      playerjs.assert(args.length > 0, 'Get methods require a callback.');\n      args.unshift(data);\n    } else {\n      //for setter add the first arg to the value field\n      if (/^set/.test(name)) {\n        playerjs.assert(args.length !== 0, 'Set methods require a value.');\n        data.value = args[0];\n      }\n      args = [data];\n    }\n\n    this.send.apply(this, args);\n  };\n}\n\n// Loop through the methods to add them to the prototype.\nfor (var i = 0, l = playerjs.METHODS.all().length; i < l; i++) {\n  var methodName = playerjs.METHODS.all()[i];\n\n  // We don't want to overwrite existing methods.\n  if (!playerjs.Player.prototype.hasOwnProperty(methodName)){\n    playerjs.Player.prototype[methodName] = createPrototypeFunction(methodName);\n  }\n}\n\n// We need to catch all ready events in case the iframe is ready before the\n// player is invoked.\nplayerjs.addEvent(window, 'message', function(e){\n  var data;\n  try {\n    data = JSON.parse(e.data);\n  } catch (err){\n    return false;\n  }\n\n  // abort if this message wasn't a player.js message\n  if (data.context !== playerjs.CONTEXT) {\n    return false;\n  }\n\n  // We need to determine if we are ready.\n  if (data.event === 'ready' && data.value && data.value.src){\n    playerjs.READIED.push(data.value.src);\n  }\n});\n\n/*\n* Does all the wiring up for the backend.\n*\n* var receiver = new playerjs.Receiver();\n* receiver.on('play', function(){ video.play() });\n* receiver.on('getDuration', function(callback){ callback(video.duration) });\n* receiver.emit('timeupdate', {});\n*/\n\nplayerjs.Receiver = function(events, methods){\n  this.init(events, methods);\n};\n\nplayerjs.Receiver.prototype.init = function(events, methods){\n  var self = this;\n\n  // Deal with the ready crap.\n  this.isReady = false;\n\n  // Bind the window message.\n  this.origin = playerjs.origin(document.referrer);\n\n  //Create a holder for all the methods.\n  this.methods = {};\n\n  // holds all the information about what's supported\n  this.supported = {\n    events: events ? events : playerjs.EVENTS.all(),\n    methods: methods ? methods : playerjs.METHODS.all()\n  };\n\n  // Deals with the adding and removing of event listeners.\n  this.eventListeners = {};\n\n  // We can't send any messages.\n  this.reject = !(window.self !== window.top && playerjs.POST_MESSAGE);\n\n  // We aren't in an iframe, don't listen.\n  if (!this.reject){\n    playerjs.addEvent(window, 'message', function(e){\n      self.receive(e);\n    });\n  }\n};\n\nplayerjs.Receiver.prototype.receive = function(e){\n  // Only want to listen to events that came from our origin.\n  if (e.origin !== this.origin){\n    return false;\n  }\n\n  // Browsers that support postMessage also support JSON.\n  var data = {};\n  if (playerjs.isObject(e.data)){\n    data = e.data;\n  } else {\n    try {\n      data = window.JSON.parse(e.data);\n    } catch (err){\n      playerjs.log('JSON Parse Error', err);\n    }\n  }\n\n  playerjs.log('Receiver.receive', e, data);\n\n  // Nothing for us to do.\n  if (!data.method){\n    return false;\n  }\n\n  // make sure the context is correct.\n  if (data.context !== playerjs.CONTEXT){\n    return false;\n  }\n\n  // Make sure we have a valid method.\n  if (playerjs.indexOf(playerjs.METHODS.all(), data.method) === -1){\n    this.emit('error', {\n      code: 2,\n      msg: 'Invalid Method \"'+data.method+'\"'\n    });\n    return false;\n  }\n\n  // See if we added a listener\n  var listener = !playerjs.isNone(data.listener) ? data.listener : null;\n\n  // Add Event Listener.\n  if (data.method === 'addEventListener') {\n    if (this.eventListeners.hasOwnProperty(data.value)) {\n      //If the listener is the same, i.e. null only add it once.\n      if (playerjs.indexOf(this.eventListeners[data.value], listener) === -1){\n        this.eventListeners[data.value].push(listener);\n      }\n    } else {\n      this.eventListeners[data.value] = [listener];\n    }\n\n    if (data.value === 'ready' && this.isReady){\n      this.ready();\n    }\n  }\n  // Remove the event listener.\n  else if (data.method === 'removeEventListener') {\n    if (this.eventListeners.hasOwnProperty(data.value)) {\n      var index = playerjs.indexOf(this.eventListeners[data.value], listener);\n\n      // if we find the element, remove it.\n      if (index > -1){\n        this.eventListeners[data.value].splice(index, 1);\n      }\n\n      if (this.eventListeners[data.value].length === 0){\n        delete this.eventListeners[data.value];\n      }\n    }\n  }\n  // Go get it.\n  else {\n    this.get(data.method, data.value, listener);\n  }\n};\n\nplayerjs.Receiver.prototype.get = function(method, value, listener){\n  var self = this;\n\n  // Now lets do it.\n  if (!this.methods.hasOwnProperty(method)){\n    this.emit('error', {\n      code: 3,\n      msg: 'Method Not Supported\"'+method+'\"'\n    });\n    return false;\n  }\n\n  var func = this.methods[method];\n\n  if (method.substr(0,3) === 'get') {\n    var callback = function(val){\n      self.send(method, val, listener);\n    };\n    func.call(this, callback);\n  } else {\n    func.call(this, value);\n  }\n};\n\nplayerjs.Receiver.prototype.on = function(event, callback){\n  this.methods[event] = callback;\n};\n\nplayerjs.Receiver.prototype.send = function(event, value, listener){\n\n  playerjs.log('Receiver.send', event, value, listener);\n\n  if (this.reject){\n    // We are not in a frame, or we don't support POST_MESSAGE\n    playerjs.log('Receiver.send.reject', event, value, listener);\n    return false;\n  }\n\n  var data = {\n    context: playerjs.CONTEXT,\n    version: playerjs.VERSION,\n    event: event\n  };\n\n  if (!playerjs.isNone(value)){\n    data.value = value;\n  }\n\n  if (!playerjs.isNone(listener)){\n    data.listener = listener;\n  }\n\n  var msg = JSON.stringify(data);\n  window.parent.postMessage(msg, this.origin === \"\" ? '*' : this.origin);\n};\n\nplayerjs.Receiver.prototype.emit = function(event, value){\n\n  if (!this.eventListeners.hasOwnProperty(event)){\n    return false;\n  }\n\n  playerjs.log('Instance.emit', event, value, this.eventListeners[event]);\n\n  for (var i=0; i < this.eventListeners[event].length; i++){\n    var listener = this.eventListeners[event][i];\n    this.send(event, value, listener);\n  }\n\n  return true;\n};\n\nplayerjs.Receiver.prototype.ready = function(){\n  playerjs.log('Receiver.ready');\n  this.isReady = true;\n\n  var data = {\n    src: window.location.toString(),\n    events: this.supported.events,\n    methods: this.supported.methods\n  };\n\n  if (!this.emit('ready', data)){\n    this.send('ready', data);\n  }\n\n};\n\nplayerjs.HTML5Adapter = function(video){\n  if (!(this instanceof playerjs.HTML5Adapter)) {\n    return new playerjs.HTML5Adapter(video);\n  }\n  this.init(video);\n};\n\nplayerjs.HTML5Adapter.prototype.init = function(video){\n\n  playerjs.assert(video, 'playerjs.HTML5Adapter requires a video element');\n\n  // Set up the actual receiver\n  var receiver = this.receiver = new playerjs.Receiver();\n\n  /* EVENTS */\n  video.addEventListener('playing', function(){\n    receiver.emit('play');\n  });\n\n  video.addEventListener('pause', function(){\n    receiver.emit('pause');\n  });\n\n  video.addEventListener('ended', function(){\n    receiver.emit('ended');\n  });\n\n  video.addEventListener('timeupdate', function(){\n    receiver.emit('timeupdate', {\n      seconds: video.currentTime,\n      duration: video.duration\n    });\n  });\n\n  video.addEventListener('progress', function(){\n    receiver.emit('buffered', {\n      percent: video.buffered.length\n    });\n  });\n\n  /* Methods */\n  receiver.on('play', function(){\n    video.play();\n  });\n\n  receiver.on('pause', function(){\n    video.pause();\n  });\n\n  receiver.on('getPaused', function(callback){\n    callback(video.paused);\n  });\n\n  receiver.on('getCurrentTime', function(callback){\n    callback(video.currentTime);\n  });\n\n  receiver.on('setCurrentTime', function(value){\n    video.currentTime = value;\n  });\n\n  receiver.on('getDuration', function(callback){\n    callback(video.duration);\n  });\n\n  receiver.on('getVolume', function(callback){\n    callback(video.volume * 100);\n  });\n\n  receiver.on('setVolume', function(value){\n    video.volume = value/100;\n  });\n\n  receiver.on('mute', function(){\n    video.muted = true;\n  });\n\n  receiver.on('unmute', function(){\n    video.muted = false;\n  });\n\n  receiver.on('getMuted', function(callback){\n    callback(video.muted);\n  });\n\n  receiver.on('getLoop', function(callback){\n    callback(video.loop);\n  });\n\n  receiver.on('setLoop', function(value){\n    video.loop = value;\n  });\n};\n\n/* Call when the video has loaded */\nplayerjs.HTML5Adapter.prototype.ready = function(){\n  this.receiver.ready();\n};\n\n//http://www.longtailvideo.com/support/jw-player/28851/javascript-api-reference\nplayerjs.JWPlayerAdapter = function(player){\n  if (!(this instanceof playerjs.JWPlayerAdapter)) {\n    return new playerjs.JWPlayerAdapter(player);\n  }\n  this.init(player);\n};\n\nplayerjs.JWPlayerAdapter.prototype.init = function(player){\n\n  playerjs.assert(player, 'playerjs.JWPlayerAdapter requires a player object');\n\n  // Set up the actual receiver\n  var receiver = this.receiver = new playerjs.Receiver();\n\n  // JWPlayer doesn't have a seLoop, so we can do it ourself.\n  this.looped = false;\n\n  /* EVENTS */\n  player.on('pause', function(){\n    receiver.emit('pause');\n  });\n\n  player.on('play', function(){\n    receiver.emit('play');\n  });\n\n  player.on('time', function(e){\n    var seconds = e.position,\n      duration = e.duration;\n\n    if (!seconds || !duration){\n      return false;\n    }\n\n    var value = {\n      seconds: seconds,\n      duration: duration\n    };\n    receiver.emit('timeupdate', value);\n  });\n\n  var self = this;\n  player.on('complete', function(){\n    // Fake the looping\n    if (self.looped === true){\n      // By default jwplayer seeks after play.\n      player.seek(0);\n    } else {\n      // Else throw the ended event.\n      receiver.emit('ended');\n    }\n  });\n\n  player.on('error', function(){\n    receiver.emit('error');\n  });\n\n\n  /* METHODS */\n  receiver.on('play', function(){\n    player.play(true);\n  });\n\n  receiver.on('pause', function(){\n    player.pause(true);\n  });\n\n  receiver.on('getPaused', function(callback){\n    callback(player.getState().toLowerCase() !== 'PLAYING'.toLowerCase());\n  });\n\n  receiver.on('getCurrentTime', function(callback){\n    callback(player.getPosition());\n  });\n\n  receiver.on('setCurrentTime', function(value){\n    player.seek(value);\n  });\n\n  receiver.on('getDuration', function(callback){\n    callback(player.getDuration());\n  });\n\n  receiver.on('getVolume', function(callback){\n    callback(player.getVolume());\n  });\n\n  receiver.on('setVolume', function(value){\n    player.setVolume(value);\n  });\n\n  receiver.on('mute', function(){\n    player.setMute(true);\n  });\n\n  receiver.on('unmute', function(){\n    player.setMute(false);\n  });\n\n  receiver.on('getMuted', function(callback){\n    callback(player.getMute() === true);\n  });\n\n  receiver.on('getLoop', function(callback){\n    callback(this.looped);\n  }, this);\n\n  receiver.on('setLoop', function(value){\n    this.looped = value;\n  }, this);\n};\n\n/* Call when the video.js is ready */\nplayerjs.JWPlayerAdapter.prototype.ready = function(){\n  this.receiver.ready();\n};\n\nplayerjs.MockAdapter = function(){\n  if (!(this instanceof playerjs.MockAdapter)) {\n    return new playerjs.MockAdapter();\n  }\n  this.init();\n};\n\nplayerjs.MockAdapter.prototype.init = function(){\n\n  // Our mock video\n  var video = {\n    duration: 20,\n    currentTime: 0,\n    interval: null,\n    timeupdate: function(){},\n    volume: 100,\n    mute: false,\n    playing: false,\n    loop : false,\n    play: function(){\n      video.interval = setInterval(function(){\n        video.currentTime += 0.25;\n        video.timeupdate({\n          seconds: video.currentTime,\n          duration: video.duration\n        });\n      }, 250);\n      video.playing = true;\n    },\n    pause: function(){\n      clearInterval(video.interval);\n      video.playing = false;\n    }\n  };\n\n  // Set up the actual receiver\n  var receiver = this.receiver = new playerjs.Receiver();\n\n  receiver.on('play', function(){\n    var self = this;\n    video.play();\n    this.emit('play');\n    video.timeupdate = function(data){\n      self.emit('timeupdate', data);\n    };\n  });\n\n  receiver.on('pause', function(){\n    video.pause();\n    this.emit('pause');\n  });\n\n  receiver.on('getPaused', function(callback){\n    callback(!video.playing);\n  });\n\n  receiver.on('getCurrentTime', function(callback){\n    callback(video.currentTime);\n  });\n\n  receiver.on('setCurrentTime', function(value){\n    video.currentTime = value;\n  });\n\n  receiver.on('getDuration', function(callback){\n    callback(video.duration);\n  });\n\n  receiver.on('getVolume', function(callback){\n    callback(video.volume);\n  });\n\n  receiver.on('setVolume', function(value){\n    video.volume = value;\n  });\n\n  receiver.on('mute', function(){\n    video.mute = true;\n  });\n\n  receiver.on('unmute', function(){\n    video.mute = false;\n  });\n\n  receiver.on('getMuted', function(callback){\n    callback(video.mute);\n  });\n\n  receiver.on('getLoop', function(callback){\n    callback(video.loop);\n  });\n\n  receiver.on('setLoop', function(value){\n    video.loop = value;\n  });\n};\n\n/* Call when the video has loaded */\nplayerjs.MockAdapter.prototype.ready = function(){\n  this.receiver.ready();\n};\nplayerjs.VideoJSAdapter = function(player){\n  if (!(this instanceof playerjs.VideoJSAdapter)) {\n    return new playerjs.VideoJSAdapter(player);\n  }\n  this.init(player);\n};\n\nplayerjs.VideoJSAdapter.prototype.init = function(player){\n\n  playerjs.assert(player, 'playerjs.VideoJSReceiver requires a player object');\n\n  // Set up the actual receiver\n  var receiver = this.receiver = new playerjs.Receiver();\n\n  /* EVENTS */\n  player.on(\"pause\", function(){\n    receiver.emit('pause');\n  });\n\n  player.on(\"play\", function(){\n    receiver.emit('play');\n  });\n\n  player.on(\"timeupdate\", function(e){\n    var seconds = player.currentTime(),\n      duration = player.duration();\n\n    if (!seconds || !duration){\n      return false;\n    }\n\n    var value = {\n      seconds: seconds,\n      duration: duration\n    };\n    receiver.emit('timeupdate', value);\n  });\n\n  player.on(\"ended\", function(){\n    receiver.emit('ended');\n  });\n\n  player.on(\"error\", function(){\n    receiver.emit('error');\n  });\n\n\n  /* METHODS */\n  receiver.on('play', function(){\n    player.play();\n  });\n\n  receiver.on('pause', function(){\n    player.pause();\n  });\n\n  receiver.on('getPaused', function(callback){\n    callback(player.paused());\n  });\n\n  receiver.on('getCurrentTime', function(callback){\n    callback(player.currentTime());\n  });\n\n  receiver.on('setCurrentTime', function(value){\n    player.currentTime(value);\n  });\n\n  receiver.on('getDuration', function(callback){\n    callback(player.duration());\n  });\n\n  receiver.on('getVolume', function(callback){\n    callback(player.volume() * 100);\n  });\n\n  receiver.on('setVolume', function(value){\n    player.volume(value/100);\n  });\n\n  receiver.on('mute', function(){\n    player.volume(0);\n  });\n\n  receiver.on('unmute', function(){\n    player.volume(1);\n  });\n\n  receiver.on('getMuted', function(callback){\n    callback(player.volume() === 0);\n  });\n\n  receiver.on('getLoop', function(callback){\n    callback(player.loop());\n  });\n\n  receiver.on('setLoop', function(value){\n    player.loop(value);\n  });\n};\n\n/* Call when the video.js is ready */\nplayerjs.VideoJSAdapter.prototype.ready = function(){\n  this.receiver.ready();\n};\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return playerjs\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(window, document);\n\n\n//# sourceURL=webpack:///../node_modules/player.js/dist/player-0.1.0.js?");

/***/ }),

/***/ "../node_modules/webpack/buildin/global.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///../node_modules/webpack/buildin/global.js?");

/***/ }),

/***/ "./ahref.js":
/*!******************!*\
  !*** ./ahref.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var utils = __webpack_require__(/*! ./utils */ \"./utils.js\");\nvar iframely = __webpack_require__(/*! ./iframely */ \"./iframely.js\");\n\niframely.on('load', function(container, href) {\n    if (container && container.nodeName && typeof href === 'string') {\n        var a = document.createElement('a');\n        a.setAttribute('href', href);\n        container.appendChild(a);\n        iframely.trigger('load', a);\n    }\n});\n\niframely.on('load', function(el) {\n\n    if (!el && !iframely.import) { \n\n        var elements = document.querySelectorAll('a[data-iframely-url]:not([data-import-uri])');\n        for(var i = 0; i < elements.length; i++) {\n            iframely.trigger('load', elements[i]);\n        }\n    }\n    \n});\n\niframely.on('load', function(el) {\n\n    if (el && el.nodeName === 'A' && (el.getAttribute('data-iframely-url') || el.getAttribute('href')) && !el.hasAttribute('data-import-uri')) {\n        unfurl(el);\n    }\n    \n});\n\nfunction unfurl(el) {\n    if (!el.getAttribute('data-iframely-url') && !el.getAttribute('href')) {\n        return; // isn't valid\n    }\n    var src;\n\n    var dataIframelyUrl = el.getAttribute('data-iframely-url');\n    if (dataIframelyUrl && /^((?:https?:)?\\/\\/[^/]+)\\/\\w+/i.test(dataIframelyUrl)) {\n        src = utils.getEndpoint(dataIframelyUrl, {\n            v: iframely.VERSION,\n            app: 1\n        });\n    } else if ((iframely.config.api_key || iframely.config.key) && iframely.CDN) {\n        src = utils.getEndpoint('/api/iframe', {\n            url: el.getAttribute('href'),\n            v: iframely.VERSION,\n            app: 1\n        }, iframely.SUPPORTED_QUERY_STRING);\n    } else {\n        console.warn('Iframely cannot build embeds: api key is required as query-string of embed.js');\n    }\n\n    if (!src) {\n        el.removeAttribute('data-iframely-url');    \n    } else {\n\n        var iframe = document.createElement('iframe');\n\n        iframe.setAttribute('allowfullscreen', '');\n        iframe.setAttribute('allow', 'autoplay; encrypted-media');\n\n        if (el.hasAttribute('data-img')) {\n            iframe.setAttribute('data-img', el.getAttribute('data-img'));\n        }\n\n        var isLazy = el.hasAttribute('data-lazy') || el.hasAttribute('data-img') || /&lazy=1/.test(src) || iframely.config.lazy;\n\n        // support restoring failed links by its text\n        var text = el.textContent || el.innerText;\n        \n        if (text && text !== '') {\n            iframe.textContent = text;\n        }        \n\n        var wrapper = utils.getIframeWrapper(el, true);\n            \n        if (wrapper) {\n\n            // Delete all in aspect wrapper.\n            while (wrapper.aspectWrapper.lastChild) {\n                wrapper.aspectWrapper.removeChild(wrapper.aspectWrapper.lastChild);\n            }\n\n        } else {\n            wrapper = utils.addDefaultWrappers(el);\n\n            var parentNode = el.parentNode;\n            parentNode.removeChild(el);\n        }\n\n        wrapper.aspectWrapper.appendChild(iframe);\n\n        if (isLazy) {\n            \n            // send to lazy iframe flow\n            iframe.setAttribute('data-iframely-url', src);\n            iframely.trigger('load', iframe);\n\n        } else {\n\n            iframe.setAttribute('src', src);\n            iframely.trigger('iframe-ready', iframe);\t\t\t\n        }\n\n\n    }\n\n\n}\n\n//# sourceURL=webpack:///./ahref.js?");

/***/ }),

/***/ "./const.js":
/*!******************!*\
  !*** ./const.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var iframely = __webpack_require__(/*! ./iframely */ \"./iframely.js\");\n\niframely.VERSION = 1;\n\niframely.ASPECT_WRAPPER_CLASS = 'iframely-responsive';\niframely.MAXWIDTH_WRAPPER_CLASS = 'iframely-embed';\niframely.LOADER_CLASS = 'iframely-loader';\n\niframely.DOMAINS = ['cdn.iframe.ly', 'iframe.ly', 'if-cdn.com', 'iframely.net'];\niframely.CDN = iframely.CDN || iframely.DOMAINS[0]; // default domain, user or script src can change CDN\n\niframely.BASE_RE = /^(?:https?:)?\\/\\/[^/]+/i;\niframely.ID_RE = /^(?:https?:)?\\/\\/[^/]+\\/(\\w+)(?:\\?.*)?$/;\niframely.SCRIPT_RE = /^(?:https?:|file:\\/)?\\/\\/[^/]+(?:.+)?\\/(?:embed|iframely)\\.js(?:[^/]+)?$/i;\niframely.CDN_RE = /^(?:https?:)?\\/\\/([^/]+)\\/(?:embed|iframely)\\.js(?:[^/]+)?$/i;\n\niframely.SUPPORTED_QUERY_STRING = ['api_key', 'key', 'iframe', 'html5', 'playerjs', 'align', 'language', 'media', 'maxwidth', 'lazy', 'import', 'parent', 'click_to_play', /^_.+/];\n\niframely.LAZY_IFRAME_SHOW_TIMEOUT = 3000;\niframely.LAZY_IFRAME_FADE_TIMEOUT = 200;\niframely.CLEAR_WRAPPER_STYLES_TIMEOUT = 3000;\n\n//# sourceURL=webpack:///./const.js?");

/***/ }),

/***/ "./deprecated.js":
/*!***********************!*\
  !*** ./deprecated.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var iframely = __webpack_require__(/*! ./iframely */ \"./iframely.js\");\n\n// deprecated. Helper function only, for the reverse compatibility.\niframely.widgets = iframely.widgets || {};\niframely.widgets.load = iframely.load;\n\nif (!iframely.events) {\n    iframely.events = {};\n    iframely.events.on = iframely.on;\n    iframely.events.trigger = iframely.trigger;\n}\n\niframely.on('cancel', function(url, parentNode, text, nextSibling) {\n    if (url && parentNode && text && text !== '') {\n        var a = document.createElement('a');\n        a.setAttribute('href', url);\n        a.setAttribute('target', '_blank');\n        a.textContent = text;\n        if (nextSibling) {\n            parentNode.insertBefore(a, nextSibling);\n        } else {\n            parentNode.appendChild(a);\n        }\n    }\n});\n\n//# sourceURL=webpack:///./deprecated.js?");

/***/ }),

/***/ "./dom-ready.js":
/*!**********************!*\
  !*** ./dom-ready.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// TODO: rename core.js to ready.js?\n\nvar iframely = __webpack_require__(/*! ./iframely */ \"./iframely.js\");\n\nvar DOMReady = function(f) {\n    if (document.readyState === 'complete' || document.readyState === 'interactive') {\n        // Run always (in case of async script).\n        setTimeout(f, 0);\n    }\n    document['addEventListener'] ? document['addEventListener']('DOMContentLoaded', f) : window.attachEvent('onload', f);\n};\n\nDOMReady(function() {\n\n    // Called each time on script load\n    iframely.trigger('load');\n});\n\n//# sourceURL=webpack:///./dom-ready.js?");

/***/ }),

/***/ "./events.js":
/*!*******************!*\
  !*** ./events.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var iframely = __webpack_require__(/*! ./iframely */ \"./iframely.js\");\n\nvar nextTick = (function(window, prefixes, i, fnc) {\n    while (!fnc && i < prefixes.length) {\n        fnc = window[prefixes[i++] + 'equestAnimationFrame'];\n    }\n    return (fnc && fnc.bind(window)) || window.setImmediate || function(fnc) {window.setTimeout(fnc, 0);};\n})(typeof window !== 'undefined' ? window : global, 'r webkitR mozR msR oR'.split(' '), 0);\n\nvar callbacksStack = {};\niframely.on = function(event, cb) {\n    var events = callbacksStack[event] = callbacksStack[event] || [];\n    events.push(cb);\n};\n\nfunction trigger(event, async, args) {\n    var events = callbacksStack[event] || [];\n    events.forEach(function(cb) {\n        if (async) {\n            nextTick(function() {\n                cb.apply(iframely, args);\n            });\n        } else {\n            cb.apply(iframely, args);\n        }\n    });\n\n    if (event === 'init') {\n        // everything inited, let's clear the callstack, just in case\n        // TODO: not good.\n        callbacksStack[event] = [];\n    }\n}\n\niframely.trigger = function(event) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    trigger(event, false, args);\n};\n\niframely.triggerAsync = function(event) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    trigger(event, true, args);\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"../node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./events.js?");

/***/ }),

/***/ "./iframely.js":
/*!*********************!*\
  !*** ./iframely.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var iframely = window.iframely = window.iframely || {};\niframely.config = iframely.config || {};\n\nmodule.exports = iframely;\n\n//# sourceURL=webpack:///./iframely.js?");

/***/ }),

/***/ "./import.js":
/*!*******************!*\
  !*** ./import.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var utils = __webpack_require__(/*! ./utils */ \"./utils.js\");\nvar iframely = __webpack_require__(/*! ./iframely */ \"./iframely.js\");\n\n// widgetsCache is used from inside import doc for js callbacks and custom features\nvar widgetsCache = {};\n\niframely.on('load', function(el) {\n\n    // load once, if import is not in process and only if query-string from script src has not disabled import\n    if (!el && iframely.config.import !== false             \n            && isImportAble()\n            && !iframely.import) {\n\n        var elements = document.querySelectorAll('a[data-iframely-url]:not([data-import-uri])');\n        if (elements.length > 1) {\n            makeImportAPICall(elements);\n        }\n    }\n\n});\n\niframely.on('load', function(widget, importOptions) {\n\n    if (widget && widget.uri && (widget.html || widget.cancel)) {\n\n        var els = widgetsCache[widget.uri];\n        // alternatively, could as well do querySelectorAll('a[data-iframely-url][data-import=\"' + template.getAttribute('data-uri') + '\"')\n\n        if (els) {\n            for (var i = 0; i < els.length; i++) {\n                loadImportWidget(widget, els[i], importOptions);\n            }\n        }\n\n        delete widgetsCache[widget.uri];\n    }\n});\n\nfunction makeImportAPICall(elements) {\n\n    var script = document.createElement('script');\n\n    var uris = [];\n    var ids = [];\n    \n    var import_options = null; // will be populated from first element; or will remain as null if no params in elements...\n\n    // couple helper functions first\n\n    function pushElement(uri, el) {\n        if (!widgetsCache[uri]) {\n            widgetsCache[uri] = [];\n        }\n\n        widgetsCache[uri].push(el);\n    }\n\n    function queueElement(el) {\n        var src = el.getAttribute('data-iframely-url');\n\n        var mId = src.match(iframely.ID_RE);\n        var id = mId && mId[1];\n\n        var options = utils.parseQueryString(src, iframely.SUPPORTED_QUERY_STRING.concat('url'));\n\n        var url = options.url; // can be undefined for IDs\n        delete options.url;\n\n        // skip import on import=0, playerjs=1\n        var skipImport = options.import === '0' || options.import === 'false' \n                    || options.playerjs === '1' || options.playerjs === 'true';\n\n        // or if link's query-string params or CDN are different from the others\n        if (!skipImport) {\n            var mBase = src.match(iframely.BASE_RE);\n            options.CDN = mBase && mBase[0]; // will fall back to iframely.CDN in getEndpoint('/import...' ...)\n\n            // set import options from the first el in import\n            // that includes api keys \n            if (!import_options) {\n                import_options = options;\n\n            // else check that this el's options are the same as the first one's in import\n            } else if (JSON.stringify(options, Object.keys(options).sort()) \n                    !== JSON.stringify(import_options, Object.keys(import_options).sort())) {\n\n                skipImport = true;\n            }\n        }\n\n\n        if (skipImport) {\n            // Usual build if no uri and app=1s.\n            iframely.trigger('load', el);\n\n        } else if (id) {\n            el.setAttribute('data-import-uri', id);\n            if (ids.indexOf(id) === -1) {\n                ids.push(id);\n            }\n            pushElement(id, el);\n\n        } else {\n\n            if (!url) {\n                url = el.getAttribute('href');\n            }\n\n            var key = import_options.key || import_options.api_key || iframely.config.api_key || iframely.config.key;\n\n            if (key && url) {\n\n                el.setAttribute('data-import-uri', url);\n                if (uris.indexOf(url) === -1) {\n                    uris.push(url);\n                }\n                pushElement(url, el);\n            } else {\n                // Usual build if no uri.\n                iframely.trigger('load', el);\n            }\n        }\n    }\n\n\n    // start actual filling up of import request\n\n    for(var i = 0; i < elements.length; i++) {\n        var el = elements[i];\n        if (!el.getAttribute('data-import-uri') && el.hasAttribute('data-iframely-url')) {\n            queueElement(el);\n        }\n    }\n\n    if ((uris.length > 0 || ids.length > 0)) {\n\n        import_options = import_options || {};\n        import_options.touch = iframely.isTouch();\n        import_options.flash = hasFlash();\n        import_options.app = 1;\n\n        if (uris.length > 0) {\n            import_options.uri = uris;\n        }\n\n        if (ids.length > 0) {\n            import_options.ids = ids.join('&');\n        }\n\n        import_options.v = iframely.VERSION;\n\n        script.src = utils.getEndpoint('/api/import/v2', import_options, iframely.SUPPORTED_QUERY_STRING);\n\n        script.onerror = function() {\n            // Error loading import. No import this time.\n            importReady();\n        };\n\n        document.head.appendChild(script);\n        iframely.import = script;\n\n    } else {\n        importReady();\n        iframely.trigger('load');\n    }\n}\n\niframely.buildImportWidgets = function(importOptions) {\n\n    iframely.trigger('import-loaded', importOptions);\n\n    importOptions.widgets.forEach(function(widget) {\n        iframely.trigger('load', widget, importOptions);\n    });\n\n    importReady();\n};\n\nfunction loadImportWidget(widgetOptions, el, importOptions) {\n\n    var needCancelWidget = widgetOptions.cancel;\n    var shadow = widgetOptions.shadow;\n    var hasRenderedEvent = widgetOptions.renderEvent;\n\n    var wrapper = utils.getIframeWrapper(el, true);\n    var widget;\n\n    if (needCancelWidget) {\n        widget = utils.getWidget(el);\n\n        iframely.cancelWidget(widget || {\n            maxWidthWrapper: el,\n            iframe: el,\n            url: el.getAttribute('href')            \n        });\n\n    } else {\n\n        widget = document.createElement('div');\n        widget.innerHTML = widgetOptions.html;\n        \n        var parent, replacedEl;\n\n        if (wrapper && !hasRenderedEvent) {\n            // Inline widget will replace 'aspectWrapper' but keep 'maxWidthWrapper' as 'iframely-embed' to fix centering, etc.\n            // If has rendered event - keep wrapper and remove attrs later by event.\n            parent = wrapper.aspectWrapper.parentNode;\n            replacedEl = wrapper.aspectWrapper;\n\n            // Clear custom attributes.\n            wrapper.maxWidthWrapper.removeAttribute('style');\n        } else {\n            // No wrapper or keep wrapper for later removal.\n            parent = el.parentNode;\n            replacedEl = el;\n        }\n\n        if (shadow) {\n\n            var shadowContainer = document.createElement('div');\n            var shadowRoot = shadowContainer.attachShadow({mode: 'open'});\n            shadowRoot.appendChild(widget);\n\n            var shadowWidgetOptions = {\n                shadowRoot: shadowRoot,\n                shadowContainer: shadowContainer,\n                container: parent,\n                context: widgetOptions.context,\n                stylesIds: widgetOptions.stylesIds,\n                stylesDict: importOptions.commonShadowStyles\n            };\n            \n            iframely.trigger('import-shadow-widget-before-render', shadowWidgetOptions);\n            \n            parent.insertBefore(shadowContainer, replacedEl);\n\n            iframely.trigger('import-shadow-widget-after-render', shadowWidgetOptions);\n            \n        } else {\n\n            parent.insertBefore(widget, replacedEl);\n\n            exec_body_scripts(widget);\n        }\n\n        parent.removeChild(replacedEl);\n\n        if (hasRenderedEvent) {\n            setTimeout(function() {\n                clearWrapperStylesAndClass(parent);\n            }, iframely.CLEAR_WRAPPER_STYLES_TIMEOUT);\n        }\n    }\n}\n\n\nfunction importReady() {\n\n    delete iframely.import;\n\n    // clean up all, let other loaders have a go\n    var failed_elements = document.querySelectorAll('a[data-iframely-url][data-import-uri]');\n    for(var i = 0; i < failed_elements.length; i++) {\n        failed_elements[i].removeAttribute('data-import-uri');\n        iframely.trigger('load', failed_elements[i]);\n    }\n}\n\niframely.isTouch = function() {\n    return 'ontouchstart' in window        // works on most browsers\n        || navigator.maxTouchPoints;       // works on IE10/11 and Surface\n};\n\nfunction hasFlash() {\n\n    var _hasFlash = false;\n\n    try {\n        var fo = new ActiveXObject('ShockwaveFlash.ShockwaveFlash');\n        if (fo) {\n            _hasFlash = true;\n        } else {\n            _hasFlash = false;\n        }\n    } catch (e) {\n        if (navigator.mimeTypes\n            && navigator.mimeTypes['application/x-shockwave-flash'] != undefined\n            && navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin) {\n            _hasFlash = true;\n        } else {\n            _hasFlash = false;\n        }\n    }\n\n    return _hasFlash;\n}\n\nfunction isImportAble() {\n\n    return document.head.attachShadow\n        && (iframely.debug || document.location.protocol === 'http:' || document.location.protocol === 'https:')  // Skip import on file:///\n        && !iframely.config.playerjs && !iframely.config.lazy;\n        // && !navigator.userAgent.toLowerCase().indexOf('firefox') > -1;\n        // TODO: test in Firefox 63\n}\n\nfunction clearWrapperStylesAndClass(el) {\n    var aspectWrapper = el;\n    var parents = 0;\n    while(aspectWrapper && aspectWrapper.getAttribute('class') !== iframely.ASPECT_WRAPPER_CLASS) {\n        aspectWrapper = aspectWrapper.parentNode;\n        parents++;\n        if (parents > 4) {\n            // Do not search further 4 parents.\n            aspectWrapper = null;\n        }\n    }\n    var maxWidthWrapper = aspectWrapper && aspectWrapper.parentNode;\n    if (maxWidthWrapper && maxWidthWrapper.getAttribute('class') === iframely.MAXWIDTH_WRAPPER_CLASS) {\n        // Remove wrapper specific data. Leave only 'iframely-embed' parent class.\n        aspectWrapper.removeAttribute('style');\n        aspectWrapper.removeAttribute('class');\n        maxWidthWrapper.removeAttribute('style');\n    }\n}\n\niframely.on('import-widget-ready', clearWrapperStylesAndClass);\n\n// used in server templates\n\nif (!iframely.addEventListener) {\n    iframely.addEventListener = function(elem, type, eventHandle) {\n        if (!elem) { return; }\n        if ( elem.addEventListener ) {\n            elem.addEventListener( type, eventHandle, false );\n        } else if ( elem.attachEvent ) {\n            elem.attachEvent( 'on' + type, eventHandle );\n        } else {\n            elem['on' + type] = eventHandle;\n        }\n    };\n}\n\nif (!iframely.newUID) {\n    iframely.newUID = function() {\n        return '' + Math.round(Math.random() * new Date().getTime());\n    };\n}\n\n// TODO: move to import script.\nfunction exec_body_scripts(body_el) {\n    function nodeName(elem, name) {\n        return elem.nodeName && elem.nodeName.toUpperCase() ===\n            name.toUpperCase();\n    }\n\n    function evalScript(elem) {\n        var data = (elem.text || elem.textContent || elem.innerHTML || '' ),\n            script = document.createElement('script');\n\n        if (elem.src) {\n            script.src = elem.src;\n        }\n        script.type = 'text/javascript';\n        try {\n            // doesn't work on ie...\n            script.appendChild(document.createTextNode(data));\n        } catch(e) {\n            // IE has funky script nodes\n            script.text = data;\n        }\n\n        body_el.appendChild(script);\n    }\n\n    // main section of function\n    var scripts = [],\n        script,\n        children_nodes = body_el.childNodes,\n        child,\n        i;\n\n    for (i = 0; children_nodes[i]; i++) {\n        child = children_nodes[i];\n        if (nodeName(child, 'script' ) &&\n            (!child.type || child.type.toLowerCase() === 'text/javascript' || child.type.toLowerCase() === 'application/javascript')) {\n            scripts.push(child);\n            body_el.removeChild(child);\n        } else {\n            exec_body_scripts(child);\n        }\n    }\n\n    for (i = 0; scripts[i]; i++) {\n        script = scripts[i];\n        if (script.parentNode) {script.parentNode.removeChild(script);}\n        evalScript(scripts[i]);\n    }\n}\n\n//# sourceURL=webpack:///./import.js?");

/***/ }),

/***/ "./index-play-on-scroll.js":
/*!*********************************!*\
  !*** ./index-play-on-scroll.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ./dom-ready */ \"./dom-ready.js\");\n\nvar iframely = __webpack_require__(/*! ./iframely */ \"./iframely.js\");\n\nif (!iframely._loaded) {\n\n    iframely._loaded = true;\n\n    __webpack_require__(/*! ./const */ \"./const.js\");\n    __webpack_require__(/*! ./events */ \"./events.js\");\n    // require('./utils');\n    __webpack_require__(/*! ./intersection */ \"./intersection.js\");\n    __webpack_require__(/*! ./import */ \"./import.js\");\n    __webpack_require__(/*! ./ahref */ \"./ahref.js\");\n    __webpack_require__(/*! ./lazy-img-placeholder */ \"./lazy-img-placeholder.js\");\n    __webpack_require__(/*! ./lazy-iframe */ \"./lazy-iframe.js\");\n    __webpack_require__(/*! ./play-on-scroll */ \"./play-on-scroll.js\");\n    // require('./messaging');\n    __webpack_require__(/*! ./widget-cancel */ \"./widget-cancel.js\");\n    __webpack_require__(/*! ./widget-resize */ \"./widget-resize.js\");\n    __webpack_require__(/*! ./widget-click */ \"./widget-click.js\");\n    __webpack_require__(/*! ./widget-options */ \"./widget-options.js\");\n    __webpack_require__(/*! ./deprecated */ \"./deprecated.js\");\n\n    iframely.trigger('init'); \n}\n\nexports.iframely = iframely;\n\n//# sourceURL=webpack:///./index-play-on-scroll.js?");

/***/ }),

/***/ "./intersection.js":
/*!*************************!*\
  !*** ./intersection.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var messaging = __webpack_require__(/*! ./messaging */ \"./messaging.js\");\nvar iframely = __webpack_require__(/*! ./iframely */ \"./iframely.js\");\n\nvar options = {\n    rootMargin: '1000px 1000px 1000px 1000px'\n    // threshold: 0\n};\n\n// only one observer instance is enough;\nvar observer;\n\nfunction getObserver() {\n    return observer || new IntersectionObserver(callback, options);\n}    \n\nfunction callback(entries) {\n    entries.forEach(function(entry) {\n        \n        messaging.postMessage({\n            method: 'intersection',\n            entry: {\n                isIntersecting: entry.isIntersecting\n            }\n        }, '*', entry.target.contentWindow);\n\n        if (entry.isIntersecting) {\n            getObserver().unobserve(entry.target);\n        }\n    });\n}\n\nif ('IntersectionObserver' in window &&\n    'IntersectionObserverEntry' in window) {\n\n    iframely.on('init', function() {\n\n        iframely.extendOptions({\n            intersection: 1\n        });\n    \n    });\n\n    iframely.on('message', function(widget, message) {\n        if (message.method === 'send-intersections' && widget.iframe) {\n            getObserver().observe(widget.iframe);\n        }\n    });\n}\n\n\n//# sourceURL=webpack:///./intersection.js?");

/***/ }),

/***/ "./lazy-iframe.js":
/*!************************!*\
  !*** ./lazy-iframe.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var utils = __webpack_require__(/*! ./utils */ \"./utils.js\");\nvar iframely = __webpack_require__(/*! ./iframely */ \"./iframely.js\");\n\n// Need 'load' handler here instead of on('init') - we load lazy iframes only when DOM ready.\niframely.on('load', function(el) {    \n\n    if (!el) { // initial load\n\n        var elements = document.querySelectorAll('iframe[data-iframely-url]');\n        for(var i = 0; i < elements.length; i++) {\n            iframely.trigger('load', elements[i]);\n        }    \n    }\n    \n});\n\niframely.on('load', function(el) {\n\n    if (el && el.nodeName === 'IFRAME'\n        && el.hasAttribute('data-iframely-url')\n        && !el.hasAttribute('data-img')\n        && !el.getAttribute('src')) {\n\n        loadLazyIframe(el);\n    }\n    \n});\n\n\nfunction loadLazyIframe(el) {\n\n    var widget = utils.getWidget(el);\n    var src = el.getAttribute('data-iframely-url');\n\n    if (widget && src) { \n\n        src = utils.getEndpoint(src, {\n            lazy: iframely.config.intersection,\n            v: iframely.VERSION,\n            app: 1 // for example, will fall back to summary card if media is not longer available\n        });\n\n    } \n\n    el.setAttribute('src', src);\n    el.removeAttribute('data-iframely-url');\n\n    iframely.trigger('iframe-ready', el);\n}\n\n//# sourceURL=webpack:///./lazy-iframe.js?");

/***/ }),

/***/ "./lazy-img-placeholder.js":
/*!*********************************!*\
  !*** ./lazy-img-placeholder.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var utils = __webpack_require__(/*! ./utils */ \"./utils.js\");\nvar iframely = __webpack_require__(/*! ./iframely */ \"./iframely.js\");\n\niframely.on('load', function(el) {\n\n    if (el && el.nodeName === 'IFRAME'\n        && el.hasAttribute('data-iframely-url')\n        && el.hasAttribute('data-img')\n        && !el.getAttribute('src')) {\n\n        el.removeAttribute('data-img');\n\n        var widget = utils.getWidget(el);\n        var src = el.getAttribute('data-iframely-url');\n\n        addPlaceholderThumbnail(widget, src);\n\n        src = utils.addQueryString(src, {img: 1});\n        el.setAttribute('data-iframely-url', src);\n\n        new WaitingWidget(widget);\n\n        iframely.trigger('load', el);\n\n    }\n});\n\niframely.on('message', function(widget, message) {\n\n    var waitingWidget;\n\n    if (message.method === 'widgetRendered') {\n        hidePlaceholderThumbnail(widget);\n\n        waitingWidget = findWaitingWidget(widget);\n        waitingWidget && waitingWidget.deactivate();\n    }\n\n    if (message.method === 'begin-waiting-widget-render') {\n        waitingWidget = findWaitingWidget(widget);\n        waitingWidget && waitingWidget.clearLoadingTimeout();\n    }\n\n    if (message.method === 'end-waiting-widget-render') {\n        waitingWidget = findWaitingWidget(widget);\n        waitingWidget && waitingWidget.registerLoadingTimeout();\n    }\n});\n\n\nfunction addPlaceholderThumbnail(widget, href) {\n\n    var thumbHref;\n\n    var query = utils.parseQueryString(href);\n\n    // Extract widget params to invalidate image cache.\n    var _params = {};\n    for(var param in query) {\n        if (param.indexOf('_') === 0) {\n            _params[param] = query[param];\n        }\n    }\n\n    // need to run through getEndpoint at least to avoid file:///\n    if (href.match(/\\/api\\/iframe/)) {\n        thumbHref = utils.getEndpoint(href.match(/^(.+)\\/api\\/iframe/i)[1] + '/api/thumbnail', Object.assign({\n            url: query.url,\n            api_key: query.api_key,\n            key: query.key\n        }, _params));\n    } else if (href.match(/^(?:https?:)?\\/\\/[^/]+\\/[a-zA-Z0-9]+(?:\\?.*)?$/)) {\n        thumbHref = utils.getEndpoint(href.replace(/^((?:https?:)?\\/\\/[^/]+\\/[a-zA-Z0-9]+)((\\?.*)?)$/, '$1/thumbnail'), _params);\n    } else {\n        return;\n    }\n\n    var thumb = document.createElement('div');\n    // Parent div not always has ASPECT_WRAPPER_CLASS. Need explicit inline styles.\n    utils.setStyles(thumb, {\n        position: 'absolute',\n        width: '100%',\n        height: '100%',\n        backgroundImage: \"url('\" + thumbHref + \"')\",\n        backgroundSize: 'cover',\n        backgroundPosition: 'center'\n    });\n\n    var iframelyLoaderDiv = document.createElement('div');\n    iframelyLoaderDiv.setAttribute('class', iframely.LOADER_CLASS);\n    thumb.appendChild(iframelyLoaderDiv);\n\n    var paddingTop = iframely.getElementComputedStyle(widget.aspectWrapper, 'padding-top');\n    var paddingBottom = iframely.getElementComputedStyle(widget.aspectWrapper, 'padding-bottom');\n\n    var paddingTopMatch = paddingTop.match(/^(\\d+)px$/);\n    var paddingTopInt = paddingTopMatch && parseInt(paddingTopMatch[1]);\n\n    if (paddingTopInt && paddingBottom) {\n\n        var thumbWrapper = document.createElement('div');\n\n        utils.setStyles(thumbWrapper, {\n            top: '-' + paddingTop,\n            width: '100%',\n            height: 0,\n            position: 'relative',\n            paddingBottom: paddingBottom\n        }); \n\n        thumbWrapper.appendChild(thumb);\n\n        widget.aspectWrapper.appendChild(thumbWrapper);\n\n    } else {\n\n        widget.aspectWrapper.appendChild(thumb);\n    }\n}\n\nfunction getNthNonTextChildNode(nth, element) {\n    var count = 0;\n    for(var i = 0; i < element.childNodes.length; i++) {\n        var el = element.childNodes[i];\n        if (el.nodeType === Node.TEXT_NODE) {\n            // Nop.\n        } else if (el.nodeType === Node.ELEMENT_NODE) {\n            if (nth === count) {\n                return el;\n            }\n            count++;\n        }\n    }\n}\n\nfunction nonTextChildCount(element) {\n    var count = 0;\n    for(var i = 0; i < element.childNodes.length; i++) {\n        var el = element.childNodes[i];\n        if (el.nodeType === Node.TEXT_NODE) {\n            var text = el.textContent || el.innerText;\n            text = text.replace(/\\s|\\n/g, '');\n            if (text) {\n                // Do not skip text node with text.\n                count++;\n            }\n        } else if (el.nodeType === Node.ELEMENT_NODE) {\n            count++;\n        }\n    }\n    return count;\n}\n\nfunction hidePlaceholderThumbnail(widget) {\n    var thumb = widget.aspectWrapper && nonTextChildCount(widget.aspectWrapper) > 1 && getNthNonTextChildNode(1, widget.aspectWrapper);\n    if (thumb && thumb.nodeName === 'DIV') {\n        widget.aspectWrapper.removeChild(thumb);\n    }\n}\n\n//===\n\n// Working WaitingWidgets' collection.\n\nvar waitingWidgets = [];\n\nfunction findWaitingWidgetIdx(widget) {\n    var i = 0;\n    while(i < waitingWidgets.length && waitingWidgets[i].widget.iframe !== widget.iframe) {\n        i++;\n    }\n    if (i < waitingWidgets.length && waitingWidgets[i].widget.iframe === widget.iframe) {\n        return i;\n    }\n}\n\nfunction findWaitingWidget(widget) {\n    var idx = findWaitingWidgetIdx(widget);\n    if (idx || idx === 0) {\n        return waitingWidgets[idx];\n    }\n}\n\nfunction removeWaitingWidget(widget) {\n    var idx = findWaitingWidgetIdx(widget);\n    if (idx || idx === 0) {\n        waitingWidgets.splice(idx, 1);\n    }\n}\n\n//===\n\n// WaitingWidget proto.\n\nfunction WaitingWidget(widget) {\n    this.widget = widget;\n    this.loadCount = 0;\n\n    var iframe = widget.iframe;\n\n    var that = this;\n    function iframeOnLoad() {\n        // Bind method to self.\n        that.iframeOnLoad();\n    }\n\n    iframe['addEventListener'] ? iframe['addEventListener']('load', iframeOnLoad) : iframe.attachEvent('onload', iframeOnLoad);\n\n    this.registerLoadingTimeout();\n\n    waitingWidgets.push(this);\n}\n\nWaitingWidget.prototype.iframeOnLoad = function() {\n\n    this.loadCount++;\n\n    // Skip first load of hosted widget OR timeout call.\n    if (this.loadCount !== 2) {\n        return;\n    }\n\n    this.deactivate();\n\n    var that = this;\n    setTimeout(function() {\n        hidePlaceholderThumbnail(that.widget);\n    }, iframely.LAZY_IFRAME_FADE_TIMEOUT);\n};\n\nWaitingWidget.prototype.deactivate = function() {\n    this.clearLoadingTimeout();\n    removeWaitingWidget(this);\n};\n\nWaitingWidget.prototype.clearLoadingTimeout = function() {\n    this.timeoutId && clearTimeout(this.timeoutId);\n    this.timeoutId = null;\n};\n\nWaitingWidget.prototype.registerLoadingTimeout = function() {\n    if (this.timeoutId) {\n        return;\n    }\n    var that = this;\n    this.timeoutId = setTimeout(function() {\n        that.iframeOnLoad();\n    }, iframely.LAZY_IFRAME_SHOW_TIMEOUT);\n};\n\n//# sourceURL=webpack:///./lazy-img-placeholder.js?");

/***/ }),

/***/ "./messaging.js":
/*!**********************!*\
  !*** ./messaging.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var iframely = __webpack_require__(/*! ./iframely */ \"./iframely.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"./utils.js\");\n\nfunction receiveMessage(callback) {\n\n    function cb(e) {\n        var message;\n        try {\n            message = JSON.parse(e.data);\n        } catch (ex) {\n        }\n\n        callback(e, message);\n    }\n\n    // browser supports window.postMessage\n    if (window['postMessage']) {\n        if (window['addEventListener']) {\n            window[callback ? 'addEventListener' : 'removeEventListener']('message', cb, !1);\n        } else {\n            window[callback ? 'attachEvent' : 'detachEvent']('onmessage', cb);\n        }\n    }\n}\n\nfunction findIframeByContentWindow(iframes, contentWindow) {\n    var foundIframe;\n    for(var i = 0; i < iframes.length && !foundIframe; i++) {\n        var iframe = iframes[i];\n        if (iframe.contentWindow === contentWindow) {\n            foundIframe = iframe;\n        }\n    }\n    return foundIframe;\n}\n\nfunction findIframe(options) {\n\n    var foundIframe, iframes;\n\n    if (options.src) {\n        iframes = document.querySelectorAll('iframe[src*=\"' + options.src.replace(/^https?:/, '') + '\"]');\n        foundIframe = findIframeByContentWindow(iframes, options.contentWindow);\n    }\n\n    if (!foundIframe) {\n        iframes = options.domains ?\n            document.querySelectorAll('iframe[src*=\"' + (options.domains || iframely.DOMAINS).join('\"], iframe[src*=\"') + '\"]')\n            : document.getElementsByTagName('iframe');\n        foundIframe = findIframeByContentWindow(iframes, options.contentWindow);\n    }\n\n    return foundIframe;\n}\n\n\nreceiveMessage(function(e, message) {\n\n    if (message && message.method) {\n\n        var foundIframe = findIframe({\n            contentWindow: e.source,\n            src: message.context,\n            domains: iframely.DOMAINS.concat(iframely.CDN)\n        });\n\n        if (foundIframe) {\n            var widget = utils.getWidget(foundIframe);\n            if (widget && message.url) {\n                widget.url = message.url;\n            }\n            iframely.trigger('message', widget, message);\n        }\n    }\n    \n});\n\n\nexports.postMessage = function(message, target_url, target) {\n    \n    if (window['postMessage']) {\n\n        if (typeof message === 'object') {\n            message.context = document.location.href;\n        }\n\n        message = JSON.stringify(message);\n\n        target_url = target_url || '*';\n\n        target = target || window.parent;  // default to parent\n\n        // the browser supports window.postMessage, so call it with a targetOrigin\n        // set appropriately, based on the target_url parameter.\n        target['postMessage'](message, target_url.replace( /([^:]+:\\/\\/[^/]+).*/, '$1'));\n    }\n};\n\n//# sourceURL=webpack:///./messaging.js?");

/***/ }),

/***/ "./play-on-scroll.js":
/*!***************************!*\
  !*** ./play-on-scroll.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var playerjs = __webpack_require__(/*! player.js */ \"../node_modules/player.js/dist/player-0.1.0.js\");\nvar iframely = __webpack_require__(/*! ./iframely */ \"./iframely.js\");\n\nvar options = {\n    threshold: 1    // 100% visible.\n};\n\n// only one observer instance is enough;\nvar observer;\n\nfunction getObserver() {\n    return observer || new IntersectionObserver(callback, options);\n}\n\nvar players = [];\n\nfunction findPlayer(iframe) {\n    var i = 0;\n    var result;\n    while(i < players.length && !result) {\n        if (players[i].elem === iframe) {\n            result = players[i];\n        }\n        i++;\n    }\n    return result;\n}\n\nfunction callback(entries) {\n    entries.forEach(function(entry) {\n        if (entry.isIntersecting) {\n            var player = findPlayer(entry.target);\n            player && player.play();\n        }\n    });\n}\n\nif ('IntersectionObserver' in window &&\n    'IntersectionObserverEntry' in window) {\n    iframely.on('iframe-ready', function(iframe) {\n        var player = new playerjs.Player(iframe);\n        player.on('ready', function() {\n            players.push(player);\n            getObserver().observe(iframe);\n        });\n    });\n}\n\n//# sourceURL=webpack:///./play-on-scroll.js?");

/***/ }),

/***/ "./utils.js":
/*!******************!*\
  !*** ./utils.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var iframely = __webpack_require__(/*! ./iframely */ \"./iframely.js\");\nvar messaging = __webpack_require__(/*! ./messaging */ \"./messaging.js\");\n\niframely.on('init', function() {\n\n\n    iframely.extendOptions(parseQueryStringFromScriptSrc());\n    // if it's hosted from elsewhere - we don't support customizing via query-string. \n    // iframely.CDN will be default one unless changed by user (?cdn= or iframely.CDN= )\n\n    defineDefaultStyles();\n\n    requestSizeOfExistingIframes(iframely.DOMAINS.concat(iframely.CDN.replace(/^https?:\\/\\//, '')));\n    \n});\n\niframely.load = function() {\n    var args = Array.prototype.slice.call(arguments);\n    args.unshift('load');\n    iframely.trigger.apply(this, args);\n};\n\nvar getIframeWrapper = exports.getIframeWrapper = function(iframe, checkClass) {\n\n    var aspectWrapper = iframe.parentNode;\n\n    if (!aspectWrapper\n        || aspectWrapper.nodeName !== 'DIV'\n        || nonTextChildCount(aspectWrapper) > 2 /* 2 is lazy-cover */\n        || (checkClass && aspectWrapper.getAttribute('class') !== iframely.ASPECT_WRAPPER_CLASS)\n        || (!checkClass && aspectWrapper.style.position !== 'relative' && aspectWrapper.getAttribute('class') !== iframely.ASPECT_WRAPPER_CLASS)) {\n        return;\n    }\n\n    var maxWidthWrapper = aspectWrapper.parentNode;\n\n    if (!maxWidthWrapper\n        || maxWidthWrapper.nodeName !== 'DIV'\n        || nonTextChildCount(maxWidthWrapper) > 1\n        || (checkClass && maxWidthWrapper.getAttribute('class') !== iframely.MAXWIDTH_WRAPPER_CLASS)\n        || (!checkClass && maxWidthWrapper.getAttribute('class') && !maxWidthWrapper.getAttribute('class').match(/iframely/i) /* users can modify class */)\n    ) {\n        return;\n    }\n\n    return {\n        aspectWrapper: aspectWrapper,\n        maxWidthWrapper: maxWidthWrapper\n    };\n};\n\nexports.addDefaultWrappers = function(el) {\n    var parentNode = el.parentNode;\n\n    var maxWidthWrapper = document.createElement('div');\n    maxWidthWrapper.className = iframely.MAXWIDTH_WRAPPER_CLASS;\n\n    var aspectWrapper = document.createElement('div');\n    aspectWrapper.className = iframely.ASPECT_WRAPPER_CLASS;\n\n    maxWidthWrapper.appendChild(aspectWrapper);\n\n    parentNode.insertBefore(maxWidthWrapper, el);\n\n    return {\n        aspectWrapper: aspectWrapper,\n        maxWidthWrapper: maxWidthWrapper\n    };\n};\n\nexports.getWidget = function(iframe) {\n    var wrapper = getIframeWrapper(iframe);\n    if (!wrapper) {\n        return;\n    }\n    var widget = {\n        iframe: iframe, // can actually be ahref\n        aspectWrapper: wrapper.aspectWrapper,\n        maxWidthWrapper: wrapper.maxWidthWrapper\n    };\n    if (iframe.nodeName === 'A' && iframe.hasAttribute('href')) {\n        widget.url = iframe.getAttribute('href');\n    } else if (iframe.hasAttribute('src') && /url=/.test(iframe.getAttribute('src'))) {\n        var qs = parseQueryString(iframe.getAttribute('src'));\n        if (qs.url) {\n            widget.url = qs.url;\n        }\n    }\n    return widget;\n};\n\niframely.getElementComputedStyle = function(el, style) {\n    return window.getComputedStyle && window.getComputedStyle(el).getPropertyValue(style);\n};\n\nexports.setStyles = function(el, styles) {\n    if (el) { // let's check it's still defined, just in case\n        Object.keys(styles).forEach(function(key) {\n\n            var value = styles[key];\n            if (typeof value === 'number' || (typeof value === 'string' && /^(\\d+)?\\.?(\\d+)$/.test(value))) {\n                value = value + 'px';\n            }\n\n            if (!window.getComputedStyle ||\n                // don't change CSS values in pixels, such as height:0\n                (iframely.getElementComputedStyle(el, key) != value\n                // && don't set default aspect ratio if it's defined in CSS anyway\n                && !(el.className == 'iframely-responsive' && key === 'paddingBottom' && !el.style[key] && /^56\\.2\\d+%$/.test(value)))) {\n\n                el.style[key] = value || ''; // remove style that is no longer needed\n            }\n        });\n    }\n};\n\nfunction defineDefaultStyles() {\n\n    var iframelyStylesId = 'iframely-styles';\n    var styles = document.getElementById(iframelyStylesId);\n\n    if (!styles) {\n        // copy-paste default styles from https://iframely.com/docs/omit-css\n        // box-sizing:border-box - need for iOS Safari .\n        var iframelyStyles = '.iframely-responsive{top:0;left:0;width:100%;height:0;position:relative;padding-bottom:56.25%;box-sizing:border-box;}.iframely-responsive>*{top:0;left:0;width:100%;height:100%;position:absolute;border:0;box-sizing:border-box;}';\n\n        styles = document.createElement('style');\n        styles.id = iframelyStylesId;\n        styles.type = 'text/css';\n        if (styles.styleSheet) {\n            // IE.\n            styles.styleSheet.cssText = iframelyStyles;\n        } else {\n            styles.innerHTML = iframelyStyles;\n        }\n        document.getElementsByTagName('head')[0].appendChild(styles);\n    }\n}\n\n\nvar addQueryString = exports.addQueryString = function(href, options) {\n\n    var query_string = '';\n\n    Object.keys(options).forEach(function(key) {\n        var value = options[key];\n\n        // array is used e.g. for import: uris and ids\n        if (Object.prototype.toString.call(value) === '[object Array]') {\n\n            var values = value.map(function(uri) {\n                return key + '=' + encodeURIComponent(uri);\n            });\n            query_string += '&' + values.join('&');            \n\n        } else if (typeof value !== 'undefined' && href.indexOf(key + '=') === -1 ) { // set explicitely in options, skip undefines\n\n            if (value === true) {\n                value = 1;\n            }\n\n            if (value === false) {\n                value = 0;\n            }            \n\n            query_string += '&' + key + '=' + encodeURIComponent(value);\n        }\n\n    });\n\n    return href + (query_string !== '' ? (href.indexOf('?') > -1 ? '&' : '?') + query_string.replace(/^&/, '') : '');\n};\n\nexports.getEndpoint = function(src, options, config_params) {\n\n    var endpoint = src;\n\n    if (!/^(https?:)?\\/\\//i.test(src)) {\n        endpoint = (options.CDN || iframely.CDN) + endpoint;\n        delete options.CDN;\n    }\n\n    if (!/^(?:https?:)?\\/\\//i.test(endpoint)) {\n        endpoint = '//' + endpoint;\n    }    \n\n    if (options) {\n        endpoint = addQueryString(endpoint, options);\n    }\n\n    // get additional params from config\n    if (config_params && config_params.length) {\n\n        var more_options = {};\n\n        var iframely_config_keys = Object.keys(iframely.config);\n        for (var i = 0; i < iframely_config_keys.length; i++) {\n            var key = iframely_config_keys[i];\n            if (containsString(config_params, key)) {\n                more_options[key] = iframely.config[key];\n            }\n        }\n\n        endpoint = addQueryString(endpoint, more_options);\n    }\n\n\n    if (/^(https?:)?\\/\\//i.test(endpoint) && !endpoint.match(/^(https?:)?\\/\\//i)[1] && document.location.protocol === 'file:') {        \n        endpoint = 'http:' + endpoint;\n    }\n\n    return endpoint;\n};\n\n// helper method to init more options through js code\niframely.extendOptions = function(options) {\n\n    options && Object.keys(options).forEach(function(key) {\n        var new_value = (\n            options[key] === 0 || options[key] === '0' || options[key] === false || options[key] === 'false'\n                ? false : (options[key] === 1 || options[key] === '1' || options[key] === true || options[key] === 'true'\n                    ? true : options[key]));\n\n        if (iframely.config[key] !== false) { // set new value only when undefined or not previously disabled\n            iframely.config[key] = new_value;\n        }\n    });\n\n};  \n\nfunction parseQueryStringFromScriptSrc() {\n\n    // Extract global iframely params.\n    var scripts = document.querySelectorAll('script[src*=\"embed.js\"], script[src*=\"iframely.js\"]');\n\n    for(var i = 0; i < scripts.length; i++) {\n        var src = scripts[i].getAttribute('src').replace(/&amp;/gi, '&');\n\n        if (iframely.SCRIPT_RE.test(src)) { // found the script on custom origin or default Iframely CDN\n\n            var options = parseQueryString(src, iframely.SUPPORTED_QUERY_STRING.concat('cdn'));\n\n            var m2 = src.match(iframely.CDN_RE);\n            if (m2 || options.cdn) { // ignore non-Iframely hosts such as s.imgur.com/min/embed.js\n                iframely.CDN =  options.cdn || m2[1];\n            }\n\n            if (Object.keys(options).length > 0) {\n                // give preferrence to CDN from scripts that have query-string. \n                // CDN is most critical for embeds with empty data-iframely-url\n                // and those should have at least ?api_key... in script src\n\n                return options;\n            } // or keep searching\n        }\n    }\n    // should have exited by now if any querystring found...\n    return {};\n}\n\nfunction requestSizeOfExistingIframes(domains) {\n\n    var iframes = document.querySelectorAll('iframe[src*=\"' + (domains || iframely.DOMAINS).join('\"], iframe[src*=\"') + '\"]');\n    for(var i = 0; i < iframes.length; i++) {\n        var iframe = iframes[i];\n        var src = iframe.src;\n        if (src.match(/^(https?:)?\\/\\/[^/]+\\/api\\/iframe\\?.+/)\n            || src.match(/^(https?:)?\\/\\/[^/]+\\/\\w+(\\?.*)?$/)) {\n            messaging.postMessage({\n                method: 'getSize'\n            }, '*', iframe.contentWindow);\n        }\n    }\n}        \n\nfunction nonTextChildCount(element) {\n    var count = 0;\n    for(var i = 0; i < element.childNodes.length; i++) {\n        var el = element.childNodes[i];\n        if (el.nodeType === Node.TEXT_NODE) {\n            var text = el.textContent || el.innerText;\n            text = text.replace(/\\s|\\n/g, '');\n            if (text) {\n                // Do not skip text node with text.\n                count++;\n            }\n        } else if (el.nodeType === Node.ELEMENT_NODE) {\n            count++;\n        }\n    }\n    return count;\n}\n\nfunction containsString(list, findValue) {\n    var value, i = 0;\n    while (i < list.length) {\n        value = list[i];\n\n        if (value == findValue) {\n            return true;\n        }\n\n        if (value && value.test && value.test(findValue)) {\n            return true;\n        }\n\n        i++;\n    }\n}\n\nvar parseQueryString = exports.parseQueryString = function(url, allowed_query_string) {\n    var query = url.match(/\\?(.+)/i);\n    if (query) {\n        query = query[1];\n        var data = query.split('&');\n        var result = {};\n        for(var i=0; i<data.length; i++) {\n            var item = data[i].split('=');\n            if (!allowed_query_string || containsString(allowed_query_string, item[0])) {\n                result[item[0]] = decodeURIComponent(item[1]);\n            }\n        }\n        return result;\n    } else {\n        return {};\n    }\n};\n\n//# sourceURL=webpack:///./utils.js?");

/***/ }),

/***/ "./widget-cancel.js":
/*!**************************!*\
  !*** ./widget-cancel.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var iframely = __webpack_require__(/*! ./iframely */ \"./iframely.js\");\n\niframely.on('message', function(widget, message) {\n    if (message.method === 'cancelWidget') {   \n        iframely.cancelWidget(widget);\n    }\n});\n\niframely.cancelWidget = function(widget) {\n\n    if (!widget) {\n        console.warn('iframely.cancelWidget called without widget param');\n        return;\n    }\n\n    function findParent(el, className) {\n        var found = false;\n        while(!found && el.parentNode) {\n            el = el.parentNode;\n            found = el.className && el.className.split(' ').indexOf(className) >= 0;\n        }\n        return found && el;\n    }\n\n    var parentNode = widget.maxWidthWrapper && widget.maxWidthWrapper.parentNode;\n    var naNode = widget.maxWidthWrapper;\n\n    // Try remove by parentClass first.\n    if (iframely.config && iframely.config.parent) {\n        // Remove by parent class.\n        var parentElement = findParent(widget.maxWidthWrapper, iframely.config.parent);\n\n        if (parentElement) {\n            parentNode = parentElement.parentNode;\n            naNode = parentElement;\n        }\n    }\n\n    if (widget.url) {\n        var text = widget.iframe && (widget.iframe.textContent || widget.iframe.innerText);\n\n        iframely.triggerAsync('cancel', widget.url, parentNode, text, naNode.nextSibling);\n    }\n    // Re-creating a link if people had it as <a>text</a> is now deprecated (see in deprecated.js)\n    // New use: iframely.on('cancel', function(url, parentNode, text) {...} );\n\n    parentNode.removeChild(naNode);\n};\n\n//# sourceURL=webpack:///./widget-cancel.js?");

/***/ }),

/***/ "./widget-click.js":
/*!*************************!*\
  !*** ./widget-click.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var iframely = __webpack_require__(/*! ./iframely */ \"./iframely.js\");\n\niframely.on('message', function(widget, message) {\n    if (message.method === 'open-href' || message.method === 'click') {\n        iframely.trigger(message.method, message.href);\n    }\n});\n\niframely.on('open-href', function(href) {\n\n    iframely.triggerAsync('click', href);\n\n    if (href.indexOf(window.location.origin) === 0) {\n        // Redirect top on same origin.\n        window.location.href = href;\n    } else {\n        // Open new tab on another origin.\n        window.open(href, '_blank');\n    }\n});\n\n//# sourceURL=webpack:///./widget-click.js?");

/***/ }),

/***/ "./widget-options.js":
/*!***************************!*\
  !*** ./widget-options.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var iframely = __webpack_require__(/*! ./iframely */ \"./iframely.js\");\n\niframely.on('message', function(widget, message) {\n    if (message.method === 'setIframelyEmbedOptions') {\n        // console.log('setIframelyEmbedOptions', message.data);\n        iframely.trigger('options', widget, message.data);\n    }\n});\n\n//# sourceURL=webpack:///./widget-options.js?");

/***/ }),

/***/ "./widget-resize.js":
/*!**************************!*\
  !*** ./widget-resize.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var utils = __webpack_require__(/*! ./utils */ \"./utils.js\");\nvar iframely = __webpack_require__(/*! ./iframely */ \"./iframely.js\");\n\niframely.on('message', function(widget, message) {\n    if (message.method === 'setIframelyWidgetSize' || message.method === 'resize' || message.method === 'setIframelyEmbedData') {\n\n        var frame_styles = {};\n\n        if (message.data && message.data.media && message.data.media.frame_style) {\n\n            message.data.media.frame_style.split(';').forEach(function(str) {\n\n                if(str.trim() !== '' && str.indexOf(':') > -1) {\n                    var props = str.split(':');\n                    if (props.length === 2) {\n                        frame_styles[props[0].trim()] = props[1].trim();\n                    }\n                }\n            });\n\n            widgetDecorate(widget, frame_styles);\n\n        } else if (message.method === 'setIframelyEmbedData') {\n\n            // setIframelyEmbedData always sets frame_style. If not - reset.\n            // setIframelyEmbedData without message.data resets border.\n            widgetDecorate(widget, null);\n        }\n\n        var media = message.data && message.data.media || {height: message.height};\n\n        widgetResize(widget, media);\n    }\n});\n\n// All frame_style attributes.\nvar resetWrapperBorderStyles = {'border': '', 'border-radius': '', 'box-shadow': '', 'overflow': ''};\nvar resetIframeBorderStyles = {'border': '0', 'border-radius': '', 'box-shadow': '', 'overflow': ''};\n\nfunction widgetDecorate(widget, styles) {\n\n    if (styles && widget && widget.iframe) {\n\n        if (styles['border-radius']) {\n            // fix for Chrome?\n            styles.overflow = 'hidden';\n            utils.setStyles(widget.aspectWrapper, styles);\n        } else {\n            utils.setStyles(widget.iframe, styles);\n        }\n\n    } else if (!styles && widget && widget.iframe) {\n\n        utils.setStyles(widget.aspectWrapper, resetWrapperBorderStyles);\n        utils.setStyles(widget.iframe, resetIframeBorderStyles);\n    }\n}\n\nfunction getTotalBorderWidth(widget) {\n\n    // Get frame style from iframe or aspect wrapper as in widgetDecorate for Chrome fix.\n    var frameStylesBorder = \n        (widget.iframe && widget.iframe.style.border) \n        || (widget.aspectWrapper && widget.aspectWrapper.style.border);\n\n    // Get iframe border width from frame style.\n    var borderWidth = frameStylesBorder && frameStylesBorder.match(/(\\d+)px/) || 0;\n    if (borderWidth) {\n        borderWidth = parseInt(borderWidth[1]);\n        // For width and height border size will be 2x.\n        borderWidth = borderWidth * 2;\n    }\n\n    return borderWidth;\n}\n\nfunction widgetResize(widget, media) {\n    \n    if (media && Object.keys(media).length > 0 && widget) {\n\n        var borderWidth = getTotalBorderWidth(widget);\n\n        var oldIframeHeight = window.getComputedStyle && window.getComputedStyle(widget.iframe).getPropertyValue('height');\n\n        utils.setStyles(widget.maxWidthWrapper, {\n            'max-width': media['max-width'] && (media['max-width'] + borderWidth),\n            'min-width': media['min-width'] && (media['min-width'] + borderWidth),\n            width: media.width && (media.width + borderWidth)\n        });\n\n        if (media.scrolling && widget.iframe) {\n            widget.iframe.setAttribute('scrolling', media.scrolling);\n        }\n\n        // TODO: can be not defined if default value and no height and width.\n        var aspectRatio = media['aspect-ratio'];\n\n        utils.setStyles(widget.aspectWrapper, {\n            paddingBottom: aspectRatio ? (Math.round(1000 * 100 / aspectRatio) / 1000 + '%') : 0, // if fixed-size, it will get set to 0\n            paddingTop: aspectRatio && media['padding-bottom'], // if a fixed-height padding at the bottom of responsive div is required\n            height: aspectRatio ? 0 : (media.height && (media.height  + borderWidth)) // if defined\n        });\n\n        var currentHeight = window.getComputedStyle && window.getComputedStyle(widget.iframe).getPropertyValue('height');\n\n        if (oldIframeHeight && oldIframeHeight !== currentHeight) {\n            iframely.triggerAsync('heightChanged', widget.iframe, oldIframeHeight, currentHeight);\n        }\n\n    }\n}\n\n//# sourceURL=webpack:///./widget-resize.js?");

/***/ })

/******/ });